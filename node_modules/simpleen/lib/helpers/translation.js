"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveTranslation = exports.loadTranslation = exports.translateIntoLanguage = exports.getFilePaths = exports.replaceVariablesInPath = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("@oclif/errors");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const glob_1 = (0, tslib_1.__importDefault)(require("glob"));
const api_1 = require("./api");
const fs_1 = require("fs");
const fs_2 = require("fs");
/**
 * Replace variables in provided outputPath
 *
 * @param filePath a specific matched filePath
 * @param outputPath the path including variables
 * @param language current locale
 */
function replaceVariablesInPath(filePath, outputPath, language) {
    const file = path_1.default.basename(filePath, path_1.default.extname(filePath));
    const ext = path_1.default.extname(filePath)
        ? path_1.default.extname(filePath).substr(1)
        : path_1.default.extname(filePath);
    const folder = path_1.default.basename(path_1.default.dirname(filePath));
    const targetPath = filePath.split(file)[0];
    return outputPath
        .replace("$LOCALE", language.toUpperCase())
        .replace("$locale", language.toLowerCase())
        .replace("$FOLDER", folder)
        .replace("$PATH", targetPath)
        .replace("$FILE", file)
        .replace("$EXTENSION", ext);
}
exports.replaceVariablesInPath = replaceVariablesInPath;
/**
 * Returns all matched paths
 * @param inputPath string with glob variables
 */
function getFilePaths(inputPath) {
    const options = {
        ignore: "**/node_modules/**",
        nonull: true,
    };
    return new Promise((resolve, reject) => {
        (0, glob_1.default)(inputPath, options, (err, files) => {
            if (err) {
                reject(err.message);
            }
            resolve(files);
        });
    });
}
exports.getFilePaths = getFilePaths;
/**
 * Translates into language and merge with already translated data
 * @param config loaded simpleen config file
 * @param translatedData already translated data
 * @param toBeTranslated data that needs to be translated
 * @param language the language locale, i. e. EN
 */
function translateIntoLanguage(config, dataformat, toBeTranslated, language) {
    const glossary = config.glossary && config.glossary[language]
        ? config.glossary[language]
        : undefined;
    return (0, api_1.createData)(config, "translate", {
        format: dataformat,
        interpolation: config.interpolation,
        source_language: config.source_language,
        target_language: language,
        glossary,
        text: toBeTranslated,
    }).then((data) => {
        // merge with translatedData
        return data;
    });
}
exports.translateIntoLanguage = translateIntoLanguage;
function loadTranslation(file) {
    try {
        if ((0, fs_1.existsSync)(file)) {
            const data = (0, fs_1.readFileSync)(file, "utf-8");
            return data;
        }
        // File does not exist
        throw new errors_1.CLIError(`File does not exist: ${file}`);
    }
    catch (e) {
        if (e instanceof Error) {
            // Probably file is corrupt
            throw new errors_1.CLIError(`Could not load file: ${file} \n ${e.message}`);
        }
        throw new errors_1.CLIError(`Could not load file: ${file} \n ${e}`);
    }
}
exports.loadTranslation = loadTranslation;
function saveTranslation(targetFile, dataformat, data) {
    try {
        if (dataformat === "JSON") {
            (0, fs_2.writeFileSync)(targetFile, JSON.stringify(data, null, 2));
        }
        else {
            (0, fs_2.writeFileSync)(targetFile, data);
        }
    }
    catch (e) {
        if (e instanceof Error) {
            throw new errors_1.CLIError("Could not save translation result - " + e.message);
        }
        throw new errors_1.CLIError("Could not save translation result - " + e);
    }
}
exports.saveTranslation = saveTranslation;
exports.default = {
    replaceVariablesInPath,
    getFilePaths,
    loadTranslation,
    translateIntoLanguage,
    saveTranslation,
};
